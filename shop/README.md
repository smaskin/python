Продолжим работать над каталогом товаров. На данный момент приложение действует в синхронном режиме, т.е. пользователь нажимает кнопку добавления, после чего выполняется переход на соответствующую страницу.
Усовершенствуем работу проекта: сделаем его более похожим на десктопное приложение — без всяких перезагрузок страницы. Форма должна загружаться, как модальное окно, как бы «поверх» содержимого главной страницы. После этого пользователь может указать данные нового товара и сохранить его в базе. При этом модальное окно формы должно закрываться, а изменения, т.е. строка с добавленным товаром, должна отобразиться в таблице на главной странице. Таким образом мы реализуем асинхронную работу приложения. Для этого необходимо использовать знания языка программирования JavaScript и библиотеки jQuery. Разобьем выполнение задания на несколько этапов:

1. Доработка шаблонов
goods_list.html
В первую очередь необходимо внести изменения в шаблон goods_list.html. Создадим пустую структуру вложенных блочных элементов div (три элемента). Ее содержимое будет динамически изменяться при нажатии кнопки добавления товара, т.е. будет загружаться модальное окно формы добавления товара. Данную структуру можно реализовать следующим образом:
<div class="modal fade" id="modal-good">
<div class="modal-dialog">
<div class="modal-content">

  </div>
</div>
</div>
В данном случае первый блочный элемент div с идентификатором modal-good соответствует модальному окну формы добавления товара. Второй div позволяет определить стилизацию компактного окна, а третий будет содержать html-код самой формы. Он будет динамически передаваться в этот div, и пользователь увидит на экране подгружаемую форму. Приведенный код необходимо разместить в конце шаблона goods_list.html.
Далее в этом же шаблоне goods_list.html следует изменить разметку кнопки добавления товара: убрать из тега button тег ссылки <a> и заменить его простым тегом строки span c названием кнопки. Тегу button назначить два атрибута: class (необходим для получения доступа к элементу из файла-скрипта) и data-url (позволяет идентифицировать страницу, генерируемую посредством jQuery).
Разметка кнопки при этом может принять такой вид:
<button type="button" class="js-create-good" data-url="{% url 'good_create' %}">
Следующее, что необходимо сделать с файлом goods_list.html, — подключить скрипт на языке JavaScript, который позволит силами библиотеки jQuery реализовать асинхронное взаимодействие с сервером. При этом тег script надо поместить в соответствующий тег шаблона {% block javascript %}{% endblock %}.
Поскольку динамически у нас должна обновляться не вся главная html-страница, а лишь табличная часть со списком товаров, создадим дополнительный шаблон partial_goods_list.html. В него поместим шаблонный тег цикла, отвечающего за формирование таблицы с данными. При этом в файле шаблона goods_list.html выполним импорт файла нового шаблона partial_goods_list.html.
base.html
В этом файле необходимо добавить подключение библиотеки jQuery. Для локального подключения следует скачать и поместить в директорию static/js файл с кодом библиотеки — например, jquery-3.3.1.min.js. В эту же директорию следует добавить файл bootstrap.min.js, который позволит упростить стилизацию элементов страницы.
good_create.html
Это шаблон, в котором находится разметка формы добавления товара. Его следует модифицировать, указав в атрибуте action тега form имя url-шаблона адреса, при переходе на который запускается контроллер записи в модель введенных данных. В нашем случае это шаблон good_create.html.
Также в данный шаблон необходимо поместить тег импорта разметки самой формы form.html в блочный элемент и добавить две кнопки: сохранения данных в форме и ее закрытия.
Пример кода до изменений:
<form method="post" enctype="multipart/form-data">
{% include "form.html" %}

<div class="submit-button"><input type="submit"
value="Добавить"></div>
</form>

И после изменений:
<form method="post" action="{% url 'good_create' %}" class="js-good-create-form">
{% csrf_token %}
<div class="modal-body">
{% include "form.html" %}
</div>
<div class="modal-footer">
<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
<button type="submit" class="btn btn-primary">Create good</button>
</div>
</form>
Атрибут data-dismiss со значением modal позволяет реализовать закрытие формы по нажатию данной кнопки.
form.html
В шаблон формы необходимо выполнить загрузку инструментов пакета django-widget-tweaks:
{% load widget_tweaks %}

2. Доработка контроллеров
Необходимо доработать один из двух наших контроллеров и написать третий. С первым — good_list — все в порядке, а во втором контроллере необходимо реализовать только проверку типа запроса: POST или GET. При этом также должен генерироваться экземпляр формы. Возвращать этот контроллер должен вызов дополнительного контроллера-функции save_good_form с со следующими параметрами: объект запроса, объект формы, шаблон. Поскольку данный контроллер должен «открыть» форму добавления товара, в качестве шаблона следует передавать good_create.html.
Контроллер save_good_form используется для проверки валидности и формирования словаря data, в котором мы будем указывать, является ли форма валидной, а также передавать преобразованный в строку шаблон и контекст (метод render_to_string). Данный контроллер будет возвращать ответ в формате JSON. Это позволит работать с формой и контекстом из файла скрипта средствами библиотеки jQuery, то есть асинхронно делать форму и передавать данные на сторону сервера.

Пример того, как может быть реализован дополнительный контроллер save_good_form:
def save_good_form(request, form, template_name):
data = dict()
if request.method == 'POST':
if form.is_valid():
form.save()
data['form_is_valid'] = True
goods = Good_Item.objects.all()
data['html_good_list'] = render_to_string('good_list.html', {
'goods': goods
})
else:
data['form_is_valid'] = False
context = {'form': form}
data['html_form'] = render_to_string(template_name, context, request=request)
return JsonResponse(data)

3. Написание скрипта
Этот скрипт должен обрабатывать переданные в формате JSON данные: обращаться с помощью селекторов к элементам веб-страницы и осуществлять манипуляции над ними. Подразумевается динамическое обновление содержимого главной страницы: подгрузка шаблона формы, а также асинхронное (без перезагрузки главной страницы) сохранение данных в модель.
Для этого в файле сценария должны быть реализованы две функции. Первая отвечает за загрузку формы, вторая — за сохранение введенных в форму данных. Для запуска первой функции необходимо выполнить ее привязку к событию нажатия на кнопку добавления товара. Для запуска второй привязка должна быть выполнена к событию отправки формы. И функции, и инструкции их вызова должны быть сохранены в функции-обертке $(function(){....программный код….});, чтобы решить всю задачу средствами библиотеки jQuery.